

============================================================
ğŸ“‚ File: .\client_app.py
============================================================

import streamlit as st
import requests
import json

# è®¾ç½®é¡µé¢é…ç½®
st.set_page_config(page_title="Multi-Agent AI ç ”ç©¶å‘˜ (SSE)", layout="wide", page_icon="ğŸ¤–")

# API åŸºç¡€ URL
API_BASE_URL = "http://localhost:8000"

# åˆå§‹åŒ–ä¼šè¯çŠ¶æ€
if "logged_in" not in st.session_state:
    st.session_state.logged_in = False
if "token" not in st.session_state:
    st.session_state.token = None
if "username" not in st.session_state:
    st.session_state.username = None

def make_authenticated_request(method, endpoint, **kwargs):
    """å‘é€å¸¦è®¤è¯çš„è¯·æ±‚ï¼Œè‡ªåŠ¨å¤„ç† token å¤±æ•ˆ"""
    if not st.session_state.token:
        logout()
        return None
    
    headers = kwargs.pop("headers", {})
    headers["Authorization"] = f"Bearer {st.session_state.token}"
    kwargs["headers"] = headers
    
    try:
        response = requests.request(method, f"{API_BASE_URL}{endpoint}", **kwargs)
        
        if response.status_code == 401:
            st.warning("ğŸ” Token å·²è¿‡æœŸæˆ–æ— æ•ˆï¼Œè¯·é‡æ–°ç™»å½•")
            logout()
            return None
        
        return response
    except requests.exceptions.RequestException as e:
        st.error(f"ç½‘ç»œè¯·æ±‚å¤±è´¥: {str(e)}")
        return None

def logout():
    """ç™»å‡ºå¹¶æ¸…é™¤ä¼šè¯çŠ¶æ€"""
    st.session_state.logged_in = False
    st.session_state.token = None
    st.session_state.username = None
    if "messages" in st.session_state:
        del st.session_state.messages
    st.rerun()

# ç™»å½•é¡µé¢
def login_page():
    st.title("ğŸ” ç”¨æˆ·ç™»å½•")
    
    tab1, tab2 = st.tabs(["ç™»å½•", "æ³¨å†Œ"])
    
    # ç™»å½•
    with tab1:
        with st.form("login_form"):
            username = st.text_input("ç”¨æˆ·å", placeholder="è¯·è¾“å…¥ç”¨æˆ·å")
            password = st.text_input("å¯†ç ", type="password", placeholder="è¯·è¾“å…¥å¯†ç ")
            submit = st.form_submit_button("ç™»å½•")
            
            if submit:
                if not username or not password:
                    st.error("è¯·å¡«å†™å®Œæ•´ä¿¡æ¯")
                else:
                    try:
                        response = requests.post(
                            f"{API_BASE_URL}/user/login",
                            json={"username": username, "password": password}
                        )
                        
                        if response.status_code == 200:
                            data = response.json()
                            st.session_state.logged_in = True
                            st.session_state.token = data.get("token")
                            st.session_state.username = username
                            st.success("ç™»å½•æˆåŠŸï¼")
                            st.rerun()
                        else:
                            error_data = response.json()
                            st.error(f"ç™»å½•å¤±è´¥: {error_data.get('detail', 'æœªçŸ¥é”™è¯¯')}")
                    except Exception as e:
                        st.error(f"è¿æ¥å¤±è´¥: {str(e)}")
    
    # æ³¨å†Œ
    with tab2:
        with st.form("register_form"):
            new_username = st.text_input("ç”¨æˆ·å", placeholder="è¯·è¾“å…¥ç”¨æˆ·åï¼ˆ8-20ä½ï¼‰")
            new_password = st.text_input("å¯†ç ", type="password", placeholder="è¯·è¾“å…¥å¯†ç ï¼ˆ6-20ä½ï¼‰")
            confirm_password = st.text_input("ç¡®è®¤å¯†ç ", type="password", placeholder="è¯·å†æ¬¡è¾“å…¥å¯†ç ")
            submit = st.form_submit_button("æ³¨å†Œ")
            
            if submit:
                if not new_username or not new_password or not confirm_password:
                    st.error("è¯·å¡«å†™å®Œæ•´ä¿¡æ¯")
                elif len(new_username) < 8 or len(new_username) > 20:
                    st.error("ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨ 8-20 ä½ä¹‹é—´")
                elif len(new_password) < 6 or len(new_password) > 20:
                    st.error("å¯†ç é•¿åº¦å¿…é¡»åœ¨ 6-20 ä½ä¹‹é—´")
                elif new_password != confirm_password:
                    st.error("ä¸¤æ¬¡è¾“å…¥çš„å¯†ç ä¸ä¸€è‡´")
                else:
                    try:
                        response = requests.post(
                            f"{API_BASE_URL}/user/register",
                            json={"username": new_username, "password": new_password}
                        )
                        
                        if response.status_code == 200:
                            st.success("æ³¨å†ŒæˆåŠŸï¼è¯·åˆ‡æ¢åˆ°ç™»å½•é¡µé¢ç™»å½•")
                        else:
                            error_data = response.json()
                            st.error(f"æ³¨å†Œå¤±è´¥: {error_data.get('detail', 'æœªçŸ¥é”™è¯¯')}")
                    except Exception as e:
                        st.error(f"è¿æ¥å¤±è´¥: {str(e)}")

# ä¸»ç•Œé¢
def main_page():
    # ä¾§è¾¹æ 
    with st.sidebar:
        st.title("ğŸ¤– AI ç ”ç©¶å‘˜")
        
        # ç”¨æˆ·ä¿¡æ¯
        st.markdown("---")
        st.markdown("### ğŸ‘¤ ç”¨æˆ·ä¿¡æ¯")
        st.info(f"**ç”¨æˆ·å**: {st.session_state.username}")
        
        # ç™»å‡ºæŒ‰é’®
        if st.button("ğŸšª ç™»å‡º"):
            logout()
        
        st.markdown("---")
        
        # åŠŸèƒ½å¯¼èˆª
        st.header("åŠŸèƒ½å¯¼èˆª")
        page = st.radio(
            "é€‰æ‹©é¡µé¢",
            ["ğŸ’¬ æ–°å»ºç ”ç©¶", "ğŸ“š å†å²æŠ¥å‘Š", "âš™ï¸ è®¾ç½®"],
            label_visibility="collapsed"
        )
        
        st.markdown("---")
        st.markdown("### å…³äº")
        st.info("""
        è¿™æ˜¯ä¸€ä¸ªåŸºäº Multi-Agent çš„ AI ç ”ç©¶åŠ©æ‰‹ï¼Œå¯ä»¥è‡ªåŠ¨æœé›†ä¿¡æ¯ã€æ’°å†™æŠ¥å‘Šå¹¶è¿›è¡Œå®¡æ ¸ã€‚
        """)
    
    # ä¸»é¡µé¢
    st.title("ğŸ¤– Multi-Agent AI ç ”ç©¶å‘˜ (SSEç‰ˆ)")
    
    # æ ¹æ®é€‰æ‹©çš„é¡µé¢æ˜¾ç¤ºä¸åŒå†…å®¹
    if page == "ğŸ’¬ æ–°å»ºç ”ç©¶":
        st.markdown("è¾“å…¥æ‚¨çš„ç ”ç©¶ä»»åŠ¡ï¼Œè§‚å¯Ÿ AI ä»£ç†å›¢é˜Ÿå¦‚ä½•ååŒå·¥ä½œã€‚")
        
        # åˆå§‹åŒ–ä¼šè¯çŠ¶æ€ç”¨äºå­˜å‚¨èŠå¤©è®°å½•
        if "messages" not in st.session_state:
            st.session_state.messages = []

        # æ˜¾ç¤ºèŠå¤©å†å²
        for message in st.session_state.messages:
            with st.chat_message(message["role"]):
                st.markdown(message["content"])

        def parse_sse_line(line):
            """Simple parser for SSE data lines."""
            line = line.strip()
            if not line:
                return None
            if line.startswith(b"data: "):
                data_str = line[6:].decode("utf-8")
                if data_str == "[DONE]":
                    return {"type": "done"}
                try:
                    return json.loads(data_str)
                except json.JSONDecodeError:
                    return None
            return None

        # è·å–ç”¨æˆ·è¾“å…¥
        if prompt := st.chat_input("è¯·è¾“å…¥æ‚¨çš„ç ”ç©¶ä»»åŠ¡ï¼ˆä¾‹å¦‚ï¼š2025å¹´AIå‘å±•è¶‹åŠ¿ï¼‰..."):
            # æ¨¡æ‹Ÿç”¨æˆ·æ¶ˆæ¯å¹¶æ˜¾ç¤º
            with st.chat_message("user"):
                st.markdown(prompt)
            st.session_state.messages.append({"role": "user", "content": prompt})

            # åˆ›å»ºåŠ©æ‰‹æ¶ˆæ¯å®¹å™¨
            with st.spinner("AI ä»£ç†å›¢é˜Ÿæ­£åœ¨å·¥ä½œ..."):
                with st.chat_message("assistant"):
                    # åˆ›å»ºæ‰§è¡Œå†å²å®¹å™¨
                    with st.expander("ğŸ“‹ Agent æ‰§è¡Œå†å²", expanded=True):
                        history_container = st.container()
                    
                    # åˆ›å»ºå ä½ç¬¦
                    status_placeholder = st.empty()
                    content_placeholder = st.empty()
                    full_response = ""
                    execution_history = []
                    
                    try: 
                        # å‘é€ POST è¯·æ±‚å¹¶å¼€å¯æµå¼æ¥æ”¶
                        response = make_authenticated_request(
                            "POST",
                            "/report/chat/stream",
                            json={"query": prompt},
                            stream=True
                        )
                        
                        if response and response.status_code == 200:
                            # å¾ªç¯è¯»å–æµå¼å“åº”
                            for line in response.iter_lines():
                                if line:
                                    event_data = parse_sse_line(line)
                                    if event_data:
                                        msg_type = event_data.get("type")
                                        content = event_data.get("content", "")
                                        
                                        if msg_type == "status":
                                            # æ·»åŠ åˆ°æ‰§è¡Œå†å²
                                            execution_history.append(content)
                                            # æ›´æ–°æ‰§è¡Œå†å²æ˜¾ç¤º
                                            with history_container:
                                                st.markdown("### æ‰§è¡Œæ­¥éª¤")
                                                for idx, step in enumerate(execution_history, 1):
                                                    st.markdown(f"{idx}. {step}")
                                            
                                        elif msg_type == "token":
                                            # ç´¯åŠ å†…å®¹å¹¶æ˜¾ç¤ºï¼ˆæ‰“å­—æœºæ•ˆæœï¼‰
                                            full_response += content
                                            # åœ¨æœ«å°¾æ·»åŠ å…‰æ ‡ä»¥å¢å¼ºæ‰“å­—æœºæ•ˆæœ
                                            content_placeholder.markdown(full_response + "â–Œ")
                                            
                                        elif msg_type == "error":
                                            st.error(f"âŒ å‘ç”Ÿé”™è¯¯: {content}")
                                            break
                                            
                                        elif msg_type == "done":
                                            break
                                            
                            # æ¸…é™¤çŠ¶æ€ä¿¡æ¯å¹¶å±•ç¤ºæœ€ç»ˆç»“æœï¼ˆç§»é™¤å…‰æ ‡ï¼‰
                            status_placeholder.empty()
                            content_placeholder.markdown(full_response)
                            
                            # ä¿å­˜åŠ©æ‰‹å›å¤åˆ°å†å²è®°å½•
                            if full_response:
                                st.session_state.messages.append({"role": "assistant", "content": full_response})
                        else:
                            st.error(f"è¯·æ±‚å¤±è´¥: {response.status_code}")
                            
                    except Exception as e:
                        st.error(f"è¿æ¥å¤±è´¥: {str(e)}")

    elif page == "ğŸ“š å†å²æŠ¥å‘Š":
        st.markdown("## ğŸ“š å†å²ç ”ç©¶æŠ¥å‘Š")
        
        # åŠ è½½å†å²æŠ¥å‘Š
        with st.spinner("æ­£åœ¨åŠ è½½å†å²æŠ¥å‘Š..."):
            response = make_authenticated_request("GET", "/report/chat/history")
            
            if response and response.status_code == 200:
                data = response.json()
                
                if data.get("success") and data.get("data"):
                    reports = data["data"]
                    
                    if not reports:
                        st.info("æš‚æ— å†å²æŠ¥å‘Šï¼Œå¿«å»åˆ›å»ºä¸€ä¸ªå§ï¼")
                    else:
                        # æŒ‰åˆ›å»ºæ—¶é—´å€’åºæ’åˆ—
                        reports.sort(key=lambda x: x["created_at"] or "", reverse=True)
                        
                        # æ˜¾ç¤ºæŠ¥å‘Šåˆ—è¡¨
                        for idx, report in enumerate(reports):
                            report_id = report["id"]
                            topic = report["topic"]
                            content = report["content"]
                            created_at = report["created_at"]
                            
                            # åˆ›å»ºä¸€ä¸ªå¯å±•å¼€çš„åŒºåŸŸ
                            with st.expander(f"ğŸ“„ {topic}", expanded=False):
                                # æ˜¾ç¤ºåˆ›å»ºæ—¶é—´
                                if created_at:
                                    st.caption(f"åˆ›å»ºæ—¶é—´: {created_at}")
                                
                                # æ˜¾ç¤ºæŠ¥å‘Šå†…å®¹
                                st.markdown(content)
                                
                                # æ·»åŠ æ“ä½œæŒ‰é’®
                                col1, col2 = st.columns(2)
                                with col1:
                                    if st.button("ğŸ“‹ å¤åˆ¶å†…å®¹", key=f"copy_{report_id}"):
                                        st.code(content, language=None)
                                        st.success("å†…å®¹å·²æ˜¾ç¤ºï¼Œå¯ä»¥æ‰‹åŠ¨å¤åˆ¶")
                                
                                with col2:
                                    if st.button("ğŸ—‘ï¸ åˆ é™¤æŠ¥å‘Š", key=f"delete_{report_id}"):
                                        st.warning("åˆ é™¤åŠŸèƒ½å¼€å‘ä¸­...")
                                
                                st.markdown("---")
                else:
                    st.info("æš‚æ— å†å²æŠ¥å‘Š")
            elif response:
                st.error(f"åŠ è½½å¤±è´¥: {response.status_code}")

    elif page == "âš™ï¸ è®¾ç½®":
        st.markdown("## âš™ï¸ ç³»ç»Ÿè®¾ç½®")
        st.info("è®¾ç½®åŠŸèƒ½å¼€å‘ä¸­...")

# ä¸»ç¨‹åº
if not st.session_state.logged_in:
    login_page()
else:
    main_page()


============================================================
ğŸ“‚ File: .\main.py
============================================================

from contextlib import asynccontextmanager
from fastapi import FastAPI
from config.db_conf import init_db
from routers import report
from models.users import User, Token
from routers import user



@asynccontextmanager
async def lifespan(app: FastAPI):
    """åº”ç”¨ç”Ÿå‘½å‘¨æœŸç®¡ç†"""
    await init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    yield
    print("ğŸ‘‹ åº”ç”¨å…³é—­")

# åˆå§‹åŒ– FastAPI åº”ç”¨
app = FastAPI(lifespan=lifespan)

app.include_router(report.router)
app.include_router(user.router)





============================================================
ğŸ“‚ File: .\é¢è¯•å‡†å¤‡æ–‡æ¡£.md
============================================================

# Multi-Agent AIç ”ç©¶åŠ©æ‰‹ - é¢è¯•å‡†å¤‡æ–‡æ¡£

## é¡¹ç›®æ¦‚è¿°

åŸºäºLangGraphçš„å¤šAgentåä½œç³»ç»Ÿï¼Œæ”¯æŒæ–‡æœ¬ç”Ÿæˆã€ä»£ç ç”Ÿæˆã€æ•°æ®åˆ†æç­‰å¤šç§ä»»åŠ¡ç±»å‹ã€‚

## æ ¸å¿ƒæŠ€æœ¯æ ˆ

- **åç«¯æ¡†æ¶**: FastAPI + SQLAlchemy
- **å‰ç«¯æ¡†æ¶**: Streamlit
- **AIæ¡†æ¶**: LangChain + LangGraph
- **æ•°æ®åº“**: PostgreSQL
- **è®¤è¯**: JWT Token + bcrypt

## é¡¹ç›®æ¶æ„

### 1. å¤šAgentåä½œç³»ç»Ÿ

#### AgentèŠ‚ç‚¹
- **Researcher**: æœç´¢ä¿¡æ¯ï¼Œæ”¶é›†èµ„æ–™
- **Code Generator**: ç”Ÿæˆä»£ç ï¼Œå®ç°ç®—æ³•
- **Data Analyst**: åˆ†ææ•°æ®ï¼Œæä¾›æ´å¯Ÿ
- **Writer**: æ’°å†™æ–‡ç« ï¼Œæ•´åˆå†…å®¹
- **Reviewer**: å®¡æ ¸å†…å®¹ï¼Œè´¨é‡æ§åˆ¶

#### å·¥ä½œæµè®¾è®¡
```
ç”¨æˆ·ä»»åŠ¡
    â†“
Researcher (æœç´¢)
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä»£ç    â”‚   æ•°æ®   â”‚   æ ‡å‡†   â”‚
â”‚ ä»»åŠ¡    â”‚   ä»»åŠ¡   â”‚   ä»»åŠ¡   â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚         â”‚          â”‚
Code Gen  Data Analyst  Writer
     â”‚         â”‚          â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
          Writer
              â†“
         Reviewer
              â†“
      é€šè¿‡ â†’ ç»“æŸ
      ä¸é€šè¿‡ â†’ Writer (é‡å†™)
```

### 2. çŠ¶æ€ç®¡ç†

```python
class AgentState(TypedDict):
    task: str                      # ç”¨æˆ·ä»»åŠ¡
    task_type: str                 # ä»»åŠ¡ç±»å‹ï¼ˆcode/data/standardï¼‰
    search_results: List[str]      # æœç´¢ç»“æœ
    draft: str                     # è‰ç¨¿å†…å®¹
    code: str                      # ä»£ç å†…å®¹
    data_analysis: dict            # æ•°æ®åˆ†æç»“æœ
    critique: str                  # å®¡æ ¸æ„è§
    revision_count: int            # ä¿®è®¢æ¬¡æ•°
    messages: List[BaseMessage]    # æ¶ˆæ¯åˆ—è¡¨
    agent_history: List[dict]      # Agentæ‰§è¡Œå†å²
```

### 3. æ¡ä»¶åˆ†æ”¯é€»è¾‘

```python
def determine_task_type(state: AgentState):
    """æ ¹æ®ä»»åŠ¡å†…å®¹åˆ¤æ–­ä»»åŠ¡ç±»å‹"""
    task = state.get('task', '').lower()
    
    code_keywords = ['ä»£ç ', 'ç¼–ç¨‹', 'ç®—æ³•', 'å‡½æ•°', 'å®ç°', 'å†™ä¸€ä¸ª', 'å¼€å‘']
    data_keywords = ['æ•°æ®', 'åˆ†æ', 'ç»Ÿè®¡', 'è¶‹åŠ¿', 'æŠ¥å‘Š', 'å›¾è¡¨']
    
    if any(keyword in task for keyword in code_keywords):
        return "code"
    elif any(keyword in task for keyword in data_keywords):
        return "data"
    else:
        return "standard"
```

## æ ¸å¿ƒåŠŸèƒ½

### 1. æ™ºèƒ½ä»»åŠ¡è·¯ç”±
- è‡ªåŠ¨è¯†åˆ«ä»»åŠ¡ç±»å‹
- æ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©åˆé€‚çš„Agent
- æ”¯æŒä»£ç ç”Ÿæˆã€æ•°æ®åˆ†æã€æ–‡æœ¬å†™ä½œ

### 2. å¤šAgentåä½œ
- Agenté—´é€šè¿‡Stateä¼ é€’ä¿¡æ¯
- æ¯ä¸ªAgentä¸“æ³¨ç‰¹å®šä»»åŠ¡
- æ”¯æŒAgentæ‰§è¡Œå†å²è¿½è¸ª

### 3. è´¨é‡æ§åˆ¶
- å¤šè½®å®¡æ ¸æœºåˆ¶
- è‡ªåŠ¨è´¨é‡è¯„åˆ†
- äº‹å®æ ¸æŸ¥ï¼ˆå¯æ‰©å±•ï¼‰

### 4. æµå¼è¾“å‡º
- Server-Sent Events (SSE)
- å®æ—¶å±•ç¤ºAgentæ‰§è¡Œè¿‡ç¨‹
- æ‰“å­—æœºæ•ˆæœå±•ç¤ºç”Ÿæˆå†…å®¹

## æŠ€æœ¯äº®ç‚¹

### 1. LangGraphå·¥ä½œæµç¼–æ’
- ä½¿ç”¨StateGraphå®šä¹‰å¤æ‚å·¥ä½œæµ
- æ¡ä»¶è¾¹å®ç°åŠ¨æ€è·¯ç”±
- æ”¯æŒå¾ªç¯å’Œåˆ†æ”¯

### 2. Promptå·¥ç¨‹
- é’ˆå¯¹ä¸åŒAgentè®¾è®¡ä¸“é—¨çš„prompt
- ä½¿ç”¨ChatPromptTemplateç®¡ç†prompt
- æ”¯æŒpromptæ¨¡æ¿åŒ–

### 3. å¼‚æ­¥å¤„ç†
- FastAPIå¼‚æ­¥è·¯ç”±
- SQLAlchemyå¼‚æ­¥ORM
- æé«˜ç³»ç»Ÿå¹¶å‘èƒ½åŠ›

### 4. ç”¨æˆ·è®¤è¯
- Token-basedè®¤è¯
- å¯†ç åŠ å¯†å­˜å‚¨
- è‡ªåŠ¨tokenè¿‡æœŸæ£€æµ‹

## é¢è¯•å¸¸è§é—®é¢˜

### Q1: ä»‹ç»ä¸€ä¸‹ä½ çš„é¡¹ç›®æ¶æ„ï¼Ÿ

**A:** 
è¿™æ˜¯ä¸€ä¸ªåŸºäºLangGraphçš„å¤šAgentåä½œç³»ç»Ÿã€‚ç³»ç»ŸåŒ…å«5ä¸ªæ ¸å¿ƒAgentï¼š
1. Researcherè´Ÿè´£æœç´¢ä¿¡æ¯
2. Code Generatorè´Ÿè´£ç”Ÿæˆä»£ç 
3. Data Analystè´Ÿè´£æ•°æ®åˆ†æ
4. Writerè´Ÿè´£æ’°å†™å†…å®¹
5. Reviewerè´Ÿè´£å®¡æ ¸è´¨é‡

å·¥ä½œæµé‡‡ç”¨æ¡ä»¶åˆ†æ”¯è®¾è®¡ï¼Œæ ¹æ®ä»»åŠ¡ç±»å‹è‡ªåŠ¨é€‰æ‹©ä¸åŒçš„Agentè·¯å¾„ã€‚æ¯”å¦‚ä»£ç ä»»åŠ¡ä¼šèµ°"Researcher â†’ Code Generator â†’ Writer â†’ Reviewer"è·¯å¾„ï¼Œè€Œæ•°æ®åˆ†æä»»åŠ¡ä¼šèµ°"Researcher â†’ Data Analyst â†’ Writer â†’ Reviewer"è·¯å¾„ã€‚

### Q2: LangGraphæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ

**A:** 
LangGraphæ˜¯ä¸€ä¸ªç”¨äºæ„å»ºæœ‰çŠ¶æ€ã€å¤šActoråº”ç”¨çš„åº“ã€‚å®ƒåŸºäºå›¾çš„æ¦‚å¿µï¼ŒèŠ‚ç‚¹ä»£è¡¨Agentæˆ–å¤„ç†æ­¥éª¤ï¼Œè¾¹ä»£è¡¨æ•°æ®æµã€‚

æ ¸å¿ƒæ¦‚å¿µï¼š
- **StateGraph**: å®šä¹‰å·¥ä½œæµå›¾
- **Node**: æ‰§è¡Œå…·ä½“ä»»åŠ¡çš„å‡½æ•°
- **Edge**: è¿æ¥èŠ‚ç‚¹ï¼Œå®šä¹‰æ•°æ®æµå‘
- **Conditional Edge**: æ ¹æ®æ¡ä»¶åŠ¨æ€é€‰æ‹©ä¸‹ä¸€ä¸ªèŠ‚ç‚¹

æˆ‘ä½¿ç”¨StateGraphå®šä¹‰äº†æ•´ä¸ªå·¥ä½œæµï¼Œé€šè¿‡add_nodeæ·»åŠ AgentèŠ‚ç‚¹ï¼Œé€šè¿‡add_edgeå’Œadd_conditional_edgeså®šä¹‰èŠ‚ç‚¹é—´çš„è¿æ¥å…³ç³»ã€‚

### Q3: å¦‚ä½•å¤„ç†Agentä¹‹é—´çš„çŠ¶æ€ä¼ é€’ï¼Ÿ

**A:** 
é€šè¿‡AgentState TypedDictæ¥ç®¡ç†çŠ¶æ€ã€‚æ¯ä¸ªAgentèŠ‚ç‚¹æ¥æ”¶å®Œæ•´çš„Stateï¼Œè¿”å›éœ€è¦æ›´æ–°çš„å­—æ®µã€‚

ä¾‹å¦‚ï¼ŒResearcherèŠ‚ç‚¹è¿”å›search_resultsï¼ŒCode GeneratorèŠ‚ç‚¹è¿”å›codeï¼ŒWriterèŠ‚ç‚¹è¿”å›draftã€‚LangGraphä¼šè‡ªåŠ¨åˆå¹¶è¿™äº›æ›´æ–°ï¼Œä¼ é€’ç»™ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

æˆ‘è¿˜æ·»åŠ äº†agent_historyå­—æ®µï¼Œè®°å½•æ¯ä¸ªAgentçš„æ‰§è¡Œå†å²ï¼Œæ–¹ä¾¿è°ƒè¯•å’Œç›‘æ§ã€‚

### Q4: å¦‚ä½•ä¼˜åŒ–promptæ•ˆæœï¼Ÿ

**A:** 
1. **è§’è‰²è®¾å®š**: ä¸ºæ¯ä¸ªAgentè®¾å®šæ˜ç¡®çš„è§’è‰²å’ŒèŒè´£
2. **ç»“æ„åŒ–è¾“å‡º**: è¦æ±‚Agentä»¥ç‰¹å®šæ ¼å¼è¿”å›ç»“æœ
3. **ä¸Šä¸‹æ–‡æ³¨å…¥**: å°†æœç´¢ç»“æœã€æ•°æ®åˆ†æç­‰æ³¨å…¥åˆ°promptä¸­
4. **è¿­ä»£ä¼˜åŒ–**: é€šè¿‡Reviewerçš„åé¦ˆä¸æ–­æ”¹è¿›Writerçš„è¾“å‡º
5. **ç¤ºä¾‹å¼•å¯¼**: åœ¨promptä¸­æä¾›æœŸæœ›çš„è¾“å‡ºç¤ºä¾‹

### Q5: å¦‚ä½•å¤„ç†é•¿æ–‡æœ¬ç”Ÿæˆï¼Ÿ

**A:** 
1. **æµå¼è¾“å‡º**: ä½¿ç”¨SSEå®æ—¶è¿”å›ç”Ÿæˆå†…å®¹
2. **åˆ†å—å¤„ç†**: å°†é•¿ä»»åŠ¡åˆ†è§£ä¸ºå¤šä¸ªæ­¥éª¤
3. **ä¸Šä¸‹æ–‡ç®¡ç†**: åªä¿ç•™å¿…è¦çš„å†å²ä¿¡æ¯
4. **Tokené™åˆ¶**: è®¾ç½®åˆç†çš„max_tokenså‚æ•°

### Q6: å¦‚ä½•ä¿è¯ç³»ç»Ÿçš„å¯é æ€§ï¼Ÿ

**A:** 
1. **å¤šè½®å®¡æ ¸**: ReviewerèŠ‚ç‚¹è¿›è¡Œè´¨é‡æ£€æŸ¥
2. **é™åˆ¶é‡è¯•**: æœ€å¤š3æ¬¡ä¿®è®¢ï¼Œé¿å…æ— é™å¾ªç¯
3. **é”™è¯¯å¤„ç†**: æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰try-catch
4. **æ—¥å¿—è®°å½•**: è®°å½•Agentæ‰§è¡Œå†å²
5. **äº‹å®æ ¸æŸ¥**: å¯ä»¥æ‰©å±•äº‹å®æ ¸æŸ¥AgentéªŒè¯ä¿¡æ¯å‡†ç¡®æ€§

### Q7: å¦‚æœç”¨æˆ·é‡å¢åŠ ï¼Œå¦‚ä½•æ‰©å±•ç³»ç»Ÿï¼Ÿ

**A:** 
1. **æ°´å¹³æ‰©å±•**: ä½¿ç”¨è´Ÿè½½å‡è¡¡éƒ¨ç½²å¤šä¸ªå®ä¾‹
2. **ç¼“å­˜ä¼˜åŒ–**: ç¼“å­˜æœç´¢ç»“æœï¼Œå‡å°‘é‡å¤æŸ¥è¯¢
3. **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—å¤„ç†é•¿æ—¶é—´ä»»åŠ¡
4. **æ•°æ®åº“ä¼˜åŒ–**: æ·»åŠ ç´¢å¼•ï¼Œä¼˜åŒ–æŸ¥è¯¢
5. **Agentå¹¶è¡Œ**: å¯ä»¥å¹¶è¡Œæ‰§è¡ŒæŸäº›Agent

### Q8: å¦‚ä½•ç›‘æ§å’Œè°ƒè¯•Agentè¡Œä¸ºï¼Ÿ

**A:** 
1. **æ‰§è¡Œå†å²**: agent_historyè®°å½•æ¯ä¸ªAgentçš„æ‰§è¡Œæƒ…å†µ
2. **æ—¥å¿—è¾“å‡º**: æ¯ä¸ªèŠ‚ç‚¹æ‰“å°æ‰§è¡Œæ—¥å¿—
3. **çŠ¶æ€è¿½è¸ª**: å¯ä»¥æŸ¥çœ‹å®Œæ•´çš„Stateå˜åŒ–
4. **å‰ç«¯å±•ç¤º**: å®æ—¶å±•ç¤ºAgentæ‰§è¡Œæ­¥éª¤
5. **é”™è¯¯è¿½è¸ª**: æ•è·å¹¶è®°å½•æ‰€æœ‰å¼‚å¸¸

## æ¼”ç¤ºåœºæ™¯

### åœºæ™¯1: ä»£ç ç”Ÿæˆ
**è¾“å…¥**: "ç”¨Pythonå®ç°å¿«é€Ÿæ’åºç®—æ³•"

**æ‰§è¡Œæµç¨‹**:
1. Researcheræœç´¢å¿«é€Ÿæ’åºç›¸å…³ä¿¡æ¯
2. Code Generatorç”ŸæˆPythonä»£ç 
3. Writeræ•´åˆä»£ç å’Œè¯´æ˜
4. Reviewerå®¡æ ¸ä»£ç è´¨é‡

**è¾“å‡º**: å®Œæ•´çš„å¿«é€Ÿæ’åºå®ç°ï¼ŒåŒ…å«æ³¨é‡Šå’Œå¤æ‚åº¦åˆ†æ

### åœºæ™¯2: æ•°æ®åˆ†æ
**è¾“å…¥**: "åˆ†æ2025å¹´AIæŠ€æœ¯å‘å±•è¶‹åŠ¿"

**æ‰§è¡Œæµç¨‹**:
1. Researcheræœç´¢AIå‘å±•è¶‹åŠ¿æ•°æ®
2. Data Analyståˆ†ææ•°æ®ï¼Œæå–å…³é”®ç‚¹
3. Writeræ’°å†™åˆ†ææŠ¥å‘Š
4. Reviewerå®¡æ ¸æŠ¥å‘Šè´¨é‡

**è¾“å‡º**: ç»“æ„åŒ–çš„æ•°æ®åˆ†ææŠ¥å‘Šï¼ŒåŒ…å«è¶‹åŠ¿æ´å¯Ÿå’Œå»ºè®®

### åœºæ™¯3: æ–‡æœ¬å†™ä½œ
**è¾“å…¥**: "å†™ä¸€ç¯‡å…³äºäººå·¥æ™ºèƒ½çš„æ–‡ç« "

**æ‰§è¡Œæµç¨‹**:
1. Researcheræœç´¢AIç›¸å…³ä¿¡æ¯
2. Writeræ’°å†™æ–‡ç« 
3. Reviewerå®¡æ ¸æ–‡ç« è´¨é‡
4. å¦‚æœéœ€è¦ä¿®æ”¹ï¼Œè¿”å›Writeré‡å†™

**è¾“å‡º**: é«˜è´¨é‡çš„AIä¸»é¢˜æ–‡ç« 

## é¡¹ç›®æ”¶è·

1. **æ·±å…¥ç†è§£LangGraph**: æŒæ¡äº†å¤šAgentå·¥ä½œæµçš„è®¾è®¡å’Œå®ç°
2. **Promptå·¥ç¨‹**: å­¦ä¼šäº†å¦‚ä½•è®¾è®¡æœ‰æ•ˆçš„prompt
3. **ç³»ç»Ÿè®¾è®¡**: ç†è§£äº†å¦‚ä½•è®¾è®¡å¤æ‚çš„å¤šAgentç³»ç»Ÿ
4. **å¼‚æ­¥ç¼–ç¨‹**: æŒæ¡äº†FastAPIå’ŒSQLAlchemyçš„å¼‚æ­¥ä½¿ç”¨
5. **å‰ç«¯å¼€å‘**: å­¦ä¼šäº†ä½¿ç”¨Streamlitæ„å»ºäº¤äº’å¼ç•Œé¢

## æœªæ¥æ‰©å±•æ–¹å‘

1. **äº‹å®æ ¸æŸ¥Agent**: éªŒè¯AIè¾“å‡ºçš„å‡†ç¡®æ€§
2. **å¹¶è¡Œå¤„ç†**: è®©å¤šä¸ªAgentåŒæ—¶å·¥ä½œï¼Œæé«˜æ•ˆç‡
3. **ç”¨æˆ·åå¥½å­¦ä¹ **: æ ¹æ®ç”¨æˆ·åé¦ˆä¸ªæ€§åŒ–è¾“å‡º
4. **å¤šè¯­è¨€æ”¯æŒ**: æ·»åŠ ç¿»è¯‘Agent
5. **å¯è§†åŒ–**: ä¸ºæ•°æ®åˆ†æç»“æœç”Ÿæˆå›¾è¡¨

## ç®€å†æè¿°

```
é¡¹ç›®ï¼šMulti-Agent AIç ”ç©¶åŠ©æ‰‹
- è®¾è®¡å¹¶å®ç°äº†åŸºäºLangGraphçš„å¤šAgentåä½œç³»ç»Ÿ
- å¼€å‘äº†5ä¸ªä¸“ä¸šAgentï¼ˆæœç´¢ã€ä»£ç ç”Ÿæˆã€æ•°æ®åˆ†æã€å†™ä½œã€å®¡æ ¸ï¼‰
- å®ç°äº†æ¡ä»¶åˆ†æ”¯å·¥ä½œæµï¼Œæ”¯æŒä»£ç ç”Ÿæˆã€æ•°æ®åˆ†æã€æ–‡æœ¬å†™ä½œç­‰å¤šç§ä»»åŠ¡ç±»å‹
- é›†æˆäº†æµå¼è¾“å‡ºå’ŒAgentæ‰§è¡Œå†å²è¿½è¸ª
- ä½¿ç”¨FastAPI + Streamlitæ„å»ºå®Œæ•´çš„å‰åç«¯ç³»ç»Ÿ
- å®ç°äº†ç”¨æˆ·è®¤è¯å’Œæƒé™ç®¡ç†
- é€šè¿‡å¤šè½®å®¡æ ¸æœºåˆ¶ä¿è¯è¾“å‡ºè´¨é‡
```

## æŠ€æœ¯åšå®¢å¤§çº²

1. é¡¹ç›®èƒŒæ™¯å’Œç›®æ ‡
2. æŠ€æœ¯é€‰å‹ï¼ˆä¸ºä»€ä¹ˆé€‰æ‹©LangGraphï¼‰
3. ç³»ç»Ÿæ¶æ„è®¾è®¡
4. Agentè®¾è®¡å’Œå®ç°
5. å·¥ä½œæµç¼–æ’
6. çŠ¶æ€ç®¡ç†
7. é‡åˆ°çš„æŒ‘æˆ˜å’Œè§£å†³æ–¹æ¡ˆ
8. æ€§èƒ½ä¼˜åŒ–
9. æœªæ¥è§„åˆ’
10. æ€»ç»“å’Œå±•æœ›

============================================================
ğŸ“‚ File: .\config\db_conf.py
============================================================

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import declarative_base, sessionmaker

# æ•°æ®åº“è¿æ¥é…ç½®

DATABASE_URL = "mysql+aiomysql://root:123456@localhost/agent_db"

engine = create_async_engine(DATABASE_URL)
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)
Base = declarative_base()


async def init_db():
    """åˆå§‹åŒ–æ•°æ®åº“è¡¨"""
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all)
        await conn.run_sync(Base.metadata.create_all)
    print(f"å·²åˆ›å»ºçš„è¡¨: {list(Base.metadata.tables.keys())}")

async def get_db() -> AsyncSession:
    """è·å–æ•°æ®åº“ä¼šè¯"""
    async with AsyncSessionLocal() as db:
        try:
            yield db
            await db.commit()
        except Exception:
            await db.rollback()
            raise
        finally:
            await db.close()


============================================================
ğŸ“‚ File: .\crud\report.py
============================================================

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from models.report import Report


async def save_report(topic: str, content: str, db: AsyncSession, user_id: int):
    """ä¿å­˜æŠ¥å‘Šåˆ°æ•°æ®åº“"""
    report = Report(topic=topic, content=content, user_id=user_id)
    db.add(report)
    await db.commit()
    await db.refresh(report)
    return report

async def get_history_report_list(db: AsyncSession, user_id: int, report_id: int = None):
    """æ ¹æ®ç”¨æˆ·IDè·å–å†å²æŠ¥å‘Šåˆ—è¡¨"""
    if report_id:
        result = await db.execute(
            select(Report).where(
                Report.user_id == user_id,
                Report.id == report_id
            )
        )
    else:
        result = await db.execute(
            select(Report).where(Report.user_id == user_id).order_by(Report.created_at.desc())
        )
    return result.scalars().all()

async def get_all_topics(db: AsyncSession, user_id: int):
    """è·å–æ‰€æœ‰æŠ¥å‘Šçš„æ ‡é¢˜ï¼ˆtopicï¼‰"""
    result = await db.execute(
        select(Report.topic).where(Report.user_id == user_id).order_by(Report.created_at.desc())
    )
    return result.scalars().all()


============================================================
ğŸ“‚ File: .\crud\user.py
============================================================

import uuid
from datetime import datetime, timedelta
from fastapi import HTTPException
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from models.users import User, Token
from schema.user import LoginRequest, RegisterRequest
from utils.security import hash_password, verify_password


async def get_user_by_username(username: str, db: AsyncSession):
    """æ ¹æ®ç”¨æˆ·åæŸ¥è¯¢ç”¨æˆ·"""
    result = await db.execute(select(User).where(User.username == username))
    return result.scalar_one_or_none()

async def create_user(request: RegisterRequest, db: AsyncSession):
    """åˆ›å»ºç”¨æˆ·"""
    password = hash_password(request.password)
    new_user = User(
    username=request.username,
    password=password  
    )
    db.add(new_user)
    await db.commit()
    return {"msg": "ç”¨æˆ·æ³¨å†ŒæˆåŠŸ"}

async def login_user(request: LoginRequest, db: AsyncSession):
    """ç”¨æˆ·ç™»å½•"""
    user = await get_user_by_username(request.username, db)
    if not user:
        raise HTTPException(status_code=400, detail="ç”¨æˆ·åä¸å­˜åœ¨")
    if not verify_password(request.password, user.password):
        raise HTTPException(status_code=400, detail="å¯†ç é”™è¯¯")
    
    token = uuid.uuid4().hex
    expires_at = datetime.now() + timedelta(days=7)
    
    new_token = Token(
        token=token,
        user_id=user.id,
        expires_at=expires_at
    )
    
    db.add(new_token)
    await db.commit()
    
    return {"msg": "ç™»å½•æˆåŠŸ", "token": token}

async def get_current_user(token: str, db: AsyncSession):
    """æ ¹æ®tokenè·å–å½“å‰ç”¨æˆ·"""
    result = await db.execute(select(Token).where(Token.token == token))
    token_obj = result.scalar_one_or_none()
    if not token_obj:
        raise HTTPException(status_code=401, detail="tokenä¸å­˜åœ¨")
    if token_obj.expires_at < datetime.now():
        raise HTTPException(status_code=401, detail="tokenå·²è¿‡æœŸ")
    result = await db.execute(select(User).where(User.id == token_obj.user_id))
    token_obj.expires_at = datetime.now() + timedelta(days=7)
    await db.commit()
    return result.scalar_one_or_none()


============================================================
ğŸ“‚ File: .\graph\state.py
============================================================

import operator
from typing import TypedDict, Annotated, List, Union
from langchain_core.messages import BaseMessage

class AgentState(TypedDict):
    """
    ä¸ºå¤šagentå·¥ä½œæµåˆ›å»ºstate
    """
    task: str                      #ç”¨æˆ·æå‡ºçš„ä»»åŠ¡                                                                                                                                                                                                           
    task_type: str                 #ä»»åŠ¡ç±»å‹ï¼ˆcode/data/standardï¼‰
    search_results: List[str]      #æœç´¢å·¥å…·è¿”å›çš„ç»“æœ
    draft: str                     #è‰ç¨¿å†…å®¹
    code: str                      #ä»£ç å†…å®¹
    data_analysis: dict            #æ•°æ®åˆ†æç»“æœ
    critique: str                  #å®¡ç¨¿æå‡ºçš„æ„è§
    revision_count: int            #ä¿®è®¢æ¬¡æ•°
    messages: Annotated[List[BaseMessage], operator.add]   #æ¶ˆæ¯åˆ—è¡¨ï¼Œç”¨äºå­˜å‚¨æ‰€æœ‰äº¤äº’æ¶ˆæ¯
    agent_history: List[dict]      #Agentæ‰§è¡Œå†å²


============================================================
ğŸ“‚ File: .\graph\workflow.py
============================================================

from functools import lru_cache
from langgraph.graph import StateGraph, END
from graph.state import AgentState
from nodes.research import research_node
from nodes.code_generator import code_generator_node
from nodes.data_analyst import data_analyst_node
from nodes.write import writer_node
from nodes.reviewer import reviewer_node
from utils.my_llm import llm
from langchain_core.prompts import ChatPromptTemplate

@lru_cache(maxsize=128)
def determine_task_type_cached(task:str):
    """
    ä½¿ç”¨ LLM è¯†åˆ«ä»»åŠ¡ç±»å‹
    è¿”å›: 'code' | 'data' | 'standard'
    """
    
    prompt = ChatPromptTemplate.from_template("""è¯·åˆ†æä»¥ä¸‹ä»»åŠ¡ï¼Œåˆ¤æ–­å®ƒå±äºå“ªç§ç±»å‹ã€‚

ä»»åŠ¡ï¼š{task}

ç±»å‹å®šä¹‰ï¼š
- codeï¼šæ¶‰åŠä»£ç ç¼–å†™ã€ç®—æ³•å®ç°ã€ç¼–ç¨‹ã€å‡½æ•°å¼€å‘ç­‰
-  dataï¼šæ¶‰åŠæ•°æ®åˆ†æã€ç»Ÿè®¡ã€è¶‹åŠ¿åˆ†æã€å›¾è¡¨åˆ¶ä½œã€å¯è§†åŒ–ç­‰
- standardï¼šæ™®é€šæ–‡ç« å†™ä½œã€å†…å®¹åˆ›ä½œã€çŸ¥è¯†æ€»ç»“ç­‰

åªè¿”å›ç±»å‹åç§°ï¼ˆcode/data/standardï¼‰ï¼Œä¸è¦å…¶ä»–å†…å®¹ã€‚""")
    
    chain = prompt | llm
    response = chain.invoke({"task": task})
    
    task_type = response.content.strip().lower()
    
    # ç¡®ä¿è¿”å›çš„æ˜¯æœ‰æ•ˆç±»å‹
    if task_type not in ['code', 'data', 'standard']:
        task_type = 'standard'
    
    return task_type

def determine_task_type(state: AgentState):
    """
    åŒ…è£…ç¼“å­˜å‡½æ•°ï¼Œç”¨äºLangGraphè°ƒç”¨
    """
    task = state.get('task', '')
    return determine_task_type_cached(task)
    
def check_critique(state: AgentState):
    """
    æ£€æŸ¥å®¡ç¨¿æ„è§æ˜¯å¦é€šè¿‡ï¼Œè‹¥é€šè¿‡åˆ™ç»“æŸï¼Œå¦åˆ™éœ€è¦ä¿®æ”¹
    """
    if state.get("critique") == "APPROVE":
        return "end"
    return "rewrite"

# åˆ›å»ºé«˜çº§å·¥ä½œæµ
workflow = StateGraph(AgentState)

# æ·»åŠ èŠ‚ç‚¹
workflow.add_node("researcher", research_node)
workflow.add_node("writer", writer_node)
workflow.add_node("reviewer", reviewer_node)
workflow.add_node("code_generator", code_generator_node)
workflow.add_node("data_analyst", data_analyst_node)

# è®¾ç½®å…¥å£
workflow.set_entry_point("researcher")

# æ·»åŠ æ¡ä»¶è¾¹ï¼šæ ¹æ®ä»»åŠ¡ç±»å‹é€‰æ‹©ä¸åŒè·¯å¾„
workflow.add_conditional_edges(
    "researcher",
    determine_task_type,
    {
        "code": "code_generator",    # ä»£ç ä»»åŠ¡ â†’ ä»£ç ç”ŸæˆAgent
        "data": "data_analyst",      # æ•°æ®ä»»åŠ¡ â†’ æ•°æ®åˆ†æAgent
        "standard": "writer"         # æ ‡å‡†ä»»åŠ¡ â†’ å†™ä½œAgent
    }
)

# ä»£ç ç”Ÿæˆè·¯å¾„
workflow.add_edge("code_generator", "writer")

# æ•°æ®åˆ†æè·¯å¾„
workflow.add_edge("data_analyst", "writer")

# å†™ä½œ â†’ å®¡æ ¸
workflow.add_edge("writer", "reviewer")

# å®¡æ ¸ç»“æœï¼šé€šè¿‡æˆ–é‡å†™
workflow.add_conditional_edges(
    "reviewer",
    check_critique,
    {
        "end": END,
        "rewrite": "writer"
    }
)

# ç¼–è¯‘å›¾
app = workflow.compile()


============================================================
ğŸ“‚ File: .\models\report.py
============================================================

from datetime import datetime
from sqlalchemy import DateTime, ForeignKey, Integer, String, Text
from sqlalchemy.orm import Mapped, mapped_column
from config.db_conf import Base
from models.users import User


class Report(Base):
    __tablename__ = "reports"

    id:Mapped[int] = mapped_column(Integer, autoincrement=True, primary_key=True, index=True)
    user_id:Mapped[int] = mapped_column(Integer, ForeignKey(User.id),index=True)
    topic:Mapped[str] = mapped_column(String(255), index=True)
    content:Mapped[str] = mapped_column(Text)
    created_at:Mapped[datetime] = mapped_column(DateTime, default=datetime.now)


============================================================
ğŸ“‚ File: .\models\users.py
============================================================

from datetime import datetime
from sqlalchemy import DateTime, ForeignKey, Integer, String
from sqlalchemy.orm import Mapped, mapped_column
from config.db_conf import Base


class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(Integer, autoincrement=True, primary_key=True, index=True)
    username: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    password: Mapped[str] = mapped_column(String(255))

class Token(Base):
    __tablename__ = "tokens"

    id: Mapped[int] = mapped_column(Integer, autoincrement=True, primary_key=True, index=True)
    user_id: Mapped[int] = mapped_column(Integer, ForeignKey(User.id), index=True)
    token: Mapped[str] = mapped_column(String(255))
    expires_at: Mapped[datetime] = mapped_column(DateTime)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)



============================================================
ğŸ“‚ File: .\nodes\code_generator.py
============================================================

from datetime import datetime

from langchain_core.prompts import ChatPromptTemplate
from utils.my_llm import llm
from graph.state import AgentState
from utils.content_cleaner import clean_code_output


def code_generator_node(state: AgentState):
    """
    ä»£ç ç”ŸæˆèŠ‚ç‚¹:æ ¹æ®ä»»åŠ¡ç”Ÿæˆä»£ç 
    """
    print("--- Code Generator: æ­£åœ¨ç”Ÿæˆä»£ç  ---")
    
    task = state.get('task', '')
    search_results = state.get('search_results', [])
    
    prompt_text = """ä½ æ˜¯ä¸€åèµ„æ·±è½¯ä»¶å·¥ç¨‹å¸ˆã€‚è¯·æ ¹æ®ä»¥ä¸‹ä»»åŠ¡ç”ŸæˆPythonä»£ç ã€‚

ä»»åŠ¡ï¼š{task}

å‚è€ƒèµ„æ–™ï¼š
{search_results}

è¦æ±‚ï¼š
1. ç”Ÿæˆå®Œæ•´ã€å¯è¿è¡Œçš„ä»£ç 
2. æ·»åŠ å¿…è¦çš„æ³¨é‡Š
3. åŒ…å«é”™è¯¯å¤„ç†
4. åŒ…å«ä½¿ç”¨ç¤ºä¾‹
5. ä»£ç é£æ ¼ç¬¦åˆæœ€ä½³å®è·µ
6. å¦‚æœæ˜¯ç®—æ³•é¢˜ï¼Œåœ¨æ³¨é‡Šä¸­æä¾›æ—¶é—´å¤æ‚åº¦åˆ†æ
"""
    
    prompt = ChatPromptTemplate.from_template(prompt_text)
    chain = prompt | llm
    
    response = chain.invoke({
        "task": task,
        "search_results": "\n".join(search_results)
    })
    
    code = response.content
    
    # åå¤„ç†æ¸…ç†
    code = clean_code_output(code)
    
    # è®°å½•Agentæ‰§è¡Œå†å²
    history = state.get('agent_history', [])
    history.append({
        "agent": "code_generator",
        "action": "generate_code",
        "timestamp": datetime.now().isoformat(),
        "input": task,
        "code_length": len(code)
    })
    
    return {"code": code, "draft": code, "agent_history": history}

============================================================
ğŸ“‚ File: .\nodes\data_analyst.py
============================================================

from datetime import datetime
from langchain_core.prompts import ChatPromptTemplate

from graph.state import AgentState
from utils.my_llm import llm


def data_analyst_node(state: AgentState):
    """
    æ•°æ®åˆ†æèŠ‚ç‚¹:åˆ†ææœç´¢ç»“æœä¸­çš„æ•°æ®
    """
    print("--- Data Analyst: æ­£åœ¨åˆ†ææ•°æ® ---")
    
    task = state.get('task', '')
    search_results = state.get('search_results', [])
    
    prompt_text = """ä½ æ˜¯ä¸€åæ•°æ®åˆ†æå¸ˆã€‚è¯·åˆ†æä»¥ä¸‹ä¿¡æ¯ä¸­çš„æ•°æ®ã€‚

ä»»åŠ¡ï¼š
{task}

ä¿¡æ¯ï¼š
{search_results}

è¦æ±‚ï¼š
1. è¯†åˆ«å…³é”®æ•°æ®ç‚¹
2. æä¾›ç»Ÿè®¡åˆ†æ
3. ç”Ÿæˆæ•°æ®æ´å¯Ÿ
4. å¦‚æœå¯èƒ½ï¼Œå»ºè®®å¯è§†åŒ–æ–¹å¼
5. ç›´æ¥è¾“å‡ºåˆ†ææŠ¥å‘Šï¼Œä¸è¦è¾“å‡ºJSONæ ¼å¼
6. ä»¥Markdownæ ¼å¼è¾“å‡ºï¼ŒåŒ…å«æ ‡é¢˜ã€å…³é”®ç‚¹ã€å»ºè®®ç­‰

è¾“å‡ºæ ¼å¼ç¤ºä¾‹ï¼š
# æ•°æ®åˆ†ææŠ¥å‘Š

## æ€»ç»“
ï¼ˆæ€»ç»“å†…å®¹ï¼‰

## å…³é”®æ•°æ®ç‚¹
1. æ•°æ®ç‚¹1
2. æ•°æ®ç‚¹2

## æ´å¯Ÿå’Œå»ºè®®
ï¼ˆæ´å¯Ÿå’Œå»ºè®®å†…å®¹ï¼‰
"""
    
    prompt = ChatPromptTemplate.from_template(prompt_text)
    chain = prompt | llm
    
    response = chain.invoke({
        "task": task,
        "search_results": "\n".join(search_results)
    })
    
    analysis_report = response.content
    
    # è®°å½•Agentæ‰§è¡Œå†å²
    history = state.get('agent_history', [])
    history.append({
        "agent": "data_analyst",
        "action": "analyze_data",
        "timestamp": datetime.now().isoformat(),
        "input": task,
        "report_length": len(analysis_report)
    })
    
    # æ•°æ®åˆ†æä»»åŠ¡ï¼šç›´æ¥è¿”å›åˆ†ææŠ¥å‘Šä½œä¸ºdraft
    return {"data_analysis": {"report": analysis_report}, "draft": analysis_report, "agent_history": history}


============================================================
ğŸ“‚ File: .\nodes\research.py
============================================================

from datetime import datetime
from graph.state import AgentState
from utils.agent_tools import tavily_search
from utils.content_cleaner import clean_search_query


def research_node(state: AgentState):
    """
    æœç´¢èŠ‚ç‚¹:é€šè¿‡æœç´¢å·¥å…·æ¥è·å–ä¿¡æ¯
    """
    print("--- Researcher: æ­£åœ¨æœç´¢ä¿¡æ¯ ---")
    task = state.get('task', '')
    
    # æ¸…ç†æœç´¢æŸ¥è¯¢
    search_query = clean_search_query(task)
    
    print(f"æœç´¢æŸ¥è¯¢: {search_query}")
    
    results = tavily_search.invoke(search_query)
    
    # è®°å½•Agentæ‰§è¡Œå†å²
    history = state.get('agent_history', [])
    history.append({
        "agent": "researcher",
        "action": "search",
        "timestamp": datetime.now().isoformat(),
        "input": task,
        "search_query": search_query,
        "output_count": len(results)
    })
    
    return {"search_results": results, "agent_history": history}

============================================================
ğŸ“‚ File: .\nodes\reviewer.py
============================================================

from datetime import datetime

from langchain_core.prompts import ChatPromptTemplate

from graph.state import AgentState
from utils.my_llm import llm


def reviewer_node(state: AgentState):
    """
    å®¡æ ¸èŠ‚ç‚¹:æ ¹æ®è‰ç¨¿å†…å®¹å’Œä»»åŠ¡è¦æ±‚è¿›è¡Œå®¡æ ¸
    """
    print("--- Reviewer: æ­£åœ¨å®¡æ ¸ ---")
    
    draft = state.get('draft', '')
    task = state.get('task', '')
    search_results = state.get('search_results', [])
    revision_count = state.get('revision_count', 0)

    # Allow maximum 3 revisions to prevent infinite loops
    if revision_count >= 3:
        print("--- Reviewer: è¾¾åˆ°æœ€å¤§ä¿®æ”¹æ¬¡æ•°ï¼Œå¼ºåˆ¶é€šè¿‡ ---")
        
        # è®°å½•Agentæ‰§è¡Œå†å²
        history = state.get('agent_history', [])
        history.append({
            "agent": "reviewer",
            "action": "review",
            "timestamp": datetime.now().isoformat(),
            "result": "force_approve",
            "reason": "max_revisions_reached"
        })
        
        return {"critique": "APPROVE", "agent_history": history}
    
    prompt_text = """ä½ æ˜¯ä¸€åä¸¥æ ¼çš„ä¸»ç¼–ã€‚è¯·å®¡æ ¸ä»¥ä¸‹å…³äº "{task}" çš„æ–‡ç« è‰ç¨¿ã€‚

å‚è€ƒèµ„æ–™ï¼š
{search_results}

è‰ç¨¿å†…å®¹ï¼š
{draft}

è¦æ±‚ï¼š
1. æ ¹æ®ç”¨æˆ·è¦æ±‚å’Œæ£€ç´¢åˆ°çš„å‚è€ƒèµ„æ–™æ£€æŸ¥è‰ç¨¿å†…å®¹æ˜¯å¦å……å®ï¼Œé€»è¾‘æ˜¯å¦ä¸¥å¯†ã€‚
2. å¦‚æœæ–‡ç« è´¨é‡åˆæ ¼ï¼Œè¯·åªè¾“å‡º "APPROVE" (ä¸å¸¦å¼•å·)ã€‚
3. å¦‚æœéœ€è¦ä¿®æ”¹ï¼Œè¯·ç»™å‡ºå…·ä½“çš„ä¿®æ”¹å»ºè®®ï¼ˆcritiqueï¼‰ï¼Œä¸è¦å¤ªé•¿ï¼Œç›´æ¥æŒ‡å‡ºé—®é¢˜ã€‚
"""
    
    prompt = ChatPromptTemplate.from_template(prompt_text)
    chain = prompt | llm
    
    response = chain.invoke({
        "task": task,
        "draft": draft,
        "search_results": "\n".join(search_results)
    })
    
    critique = response.content.strip()
    
    # Simple check if LLM approved it
    if "APPROVE" in critique:
        result = "APPROVE"
    else:
        result = critique
    
    # è®°å½•Agentæ‰§è¡Œå†å²
    history = state.get('agent_history', [])
    history.append({
        "agent": "reviewer",
        "action": "review",
        "timestamp": datetime.now().isoformat(),
        "result": result,
        "revision_count": revision_count
    })
    
    return {"critique": result, "agent_history": history}


============================================================
ğŸ“‚ File: .\nodes\write.py
============================================================

from datetime import datetime
import json
from langchain_core.prompts import ChatPromptTemplate
from graph.state import AgentState
from utils.my_llm import llm
from utils.content_cleaner import clean_article_output


def writer_node(state: AgentState):
    """
    å†™èŠ‚ç‚¹:æ ¹æ®æœç´¢å†…å®¹å’Œä¿®æ”¹æ„è§æ’°å†™è‰ç¨¿
    """
    print("--- Writer: æ­£åœ¨æ’°å†™è‰ç¨¿ ---")
    
    current_revision = state.get('revision_count', 0)
    new_revision_count = current_revision + 1
    
    task = state.get('task', '')
    search_results = state.get('search_results', [])
    critique = state.get('critique', '')
    data_analysis = state.get('data_analysis', {})
    code = state.get('code', '')

    prompt_text = """ä½ æ˜¯ä¸€åä¸“ä¸šçš„æŠ€æœ¯æ’°ç¨¿äººã€‚è¯·æ ¹æ®ä»¥ä¸‹ä¿¡æ¯æ’°å†™ä¸€ç¯‡æŠ€æœ¯æ–‡ç« ã€‚

ä»»åŠ¡ï¼š{task}

å‚è€ƒèµ„æ–™ï¼š
{search_results}

è¦æ±‚ï¼š
1. æ–‡ç« ä¸»é¢˜å›´ç»•ä»»åŠ¡ï¼š{task}
2. å†…å®¹åŸºäºæœç´¢ç»“æœï¼Œè¿›è¡Œæ•´åˆå’Œæ‰©å±•
3. è¯­è¨€é€šé¡ºï¼Œé€»è¾‘æ¸…æ™°ï¼Œç»“æ„å®Œæ•´
4. ä½¿ç”¨markdownæ ¼å¼
5. è¿™æ˜¯ç¬¬ {revision_count} ç‰ˆè‰ç¨¿
"""
    
    # å¦‚æœæœ‰ä»£ç ï¼Œæ·»åŠ è¯´æ˜
    if code:
        prompt_text += """

æ³¨æ„ï¼šå·²æœ‰ç›¸å…³ä»£ç å®ç°ï¼Œè¯·åœ¨æ–‡ç« ä¸­é€‚å½“å±•ç¤ºä»£ç ï¼Œä½¿ç”¨markdownä»£ç å—æ ¼å¼ï¼ˆ```python ... ```ï¼‰ã€‚
"""
    
    if critique:
        prompt_text += f"""

ä¸Šä¸€ç‰ˆçš„å®¡æ ¸æ„è§ï¼š{critique}
"""
        
    prompt = ChatPromptTemplate.from_template(prompt_text)
    chain = prompt | llm
    
    # å‡†å¤‡å‚æ•°
    invoke_params = {
        "task": task,
        "search_results": "\n".join(search_results),
        "revision_count": new_revision_count,
        "critique": critique
    }
    
    response = chain.invoke(invoke_params)
    
    # åå¤„ç†æ¸…ç†
    draft = clean_article_output(response.content)
    
    # è®°å½•Agentæ‰§è¡Œå†å²
    history = state.get('agent_history', [])
    history.append({
        "agent": "writer",
        "action": "write_draft",
        "timestamp": datetime.now().isoformat(),
        "input": task,
        "revision": new_revision_count,
        "draft_length": len(draft)
    })
    
    return {
        "draft": draft,
        "revision_count": new_revision_count,
        "agent_history": history
    }


============================================================
ğŸ“‚ File: .\routers\report.py
============================================================

import json
from fastapi import APIRouter, Depends, Header, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from starlette.responses import StreamingResponse
from config.db_conf import get_db
from crud.report import save_report
from crud.report import get_history_report_list
from crud.user import get_current_user
from models.users import User
from schema.report import ChatRequest
from graph.workflow import app as workflow_app


router = APIRouter(prefix="/report/chat",tags=["æŠ¥å‘Š"])

async def get_token_from_header(authorization: str = Header(...)):
    """ä»è¯·æ±‚å¤´ä¸­æå– token"""
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="æ— æ•ˆçš„è®¤è¯æ ¼å¼")
    return authorization[7:]

async def get_current_user_dependency(
    token: str = Depends(get_token_from_header),
    db: AsyncSession = Depends(get_db)
):
    """è·å–å½“å‰ç”¨æˆ·ï¼ˆä¾èµ–æ³¨å…¥ç‰ˆæœ¬ï¼‰"""
    return await get_current_user(token, db)

@router.post("/stream")
async def chat_stream(
    request: ChatRequest,
    current_user: User = Depends(get_current_user_dependency),
    db: AsyncSession = Depends(get_db)
):
    """
    ä½¿ç”¨ Server-Sent Events (SSE) æµå¼è¿”å›ç”Ÿæˆç»“æœï¼Œå¹¶ä¿å­˜åˆ°æ•°æ®åº“
    """
    
    async def event_generator():
        task = request.query
        print(f"æ”¶åˆ°ç”¨æˆ·ä»»åŠ¡: {task}")
        
        # å‘é€åˆå§‹çŠ¶æ€
        yield f"data: {json.dumps({'type': 'status', 'content': 'ä»»åŠ¡å·²æ¥æ”¶ï¼Œæ­£åœ¨å¯åŠ¨å·¥ä½œæµ...'}, ensure_ascii=False)}\n\n"
        
        # åˆå§‹åŒ–çŠ¶æ€
        initial_state = {
            "task": task,
            "revision_count": 0,
            "search_results": [],
            "messages": []
        }
        
        final_state = None
        current_draft_content = ""
        
        try:
            # ä½¿ç”¨ astream_events å…è®¸ç»†ç²’åº¦çš„äº‹ä»¶æµå¼ä¼ è¾“
            async for event in workflow_app.astream_events(initial_state, version="v2"):
                kind = event["event"]
                name = event.get("name", "")
                
                # --- å¤„ç† LangGraph èŠ‚ç‚¹å¼€å§‹äº‹ä»¶ ---
                if kind == "on_chain_start":
                    if name == "researcher":
                        yield f"data: {json.dumps({'type': 'status', 'content': 'ğŸ” ç ”ç©¶å‘˜æ­£åœ¨æœé›†ä¿¡æ¯...'}, ensure_ascii=False)}\n\n"
                    elif name == "code_generator":
                        yield f"data: {json.dumps({'type': 'status', 'content': 'ğŸ’» ä»£ç ç”Ÿæˆå™¨æ­£åœ¨ç¼–å†™ä»£ç ...'}, ensure_ascii=False)}\n\n"
                    elif name == "data_analyst":
                        yield f"data: {json.dumps({'type': 'status', 'content': 'ğŸ“Š æ•°æ®åˆ†æå¸ˆæ­£åœ¨åˆ†ææ•°æ®...'}, ensure_ascii=False)}\n\n"
                    elif name == "writer":
                        yield f"data: {json.dumps({'type': 'status', 'content': 'âœï¸ æ’°ç¨¿äººæ­£åœ¨æ’°å†™åˆç¨¿...'}, ensure_ascii=False)}\n\n"
                        # é‡ç½®å½“å‰è‰ç¨¿å†…å®¹ï¼ˆæ–°çš„ä¸€ç‰ˆï¼‰
                        current_draft_content = ""
                    elif name == "reviewer":
                        yield f"data: {json.dumps({'type': 'status', 'content': 'ğŸ‘€ å®¡ç¨¿äººæ­£åœ¨å®¡æ ¸æ–‡ç« ...'}, ensure_ascii=False)}\n\n"
                
                # --- å¤„ç† LLM çš„æµå¼è¾“å‡º ---
                elif kind == "on_chat_model_stream":
                    data = event["data"]
                    chunk = data.get("chunk")
                    if chunk and hasattr(chunk, "content") and chunk.content:
                        content_chunk = chunk.content
                        # å¦‚æœæ˜¯ Writer èŠ‚ç‚¹ï¼Œæ”¶é›†è‰ç¨¿å†…å®¹
                        if name == "writer":
                            current_draft_content += content_chunk
                        yield f"data: {json.dumps({'type': 'token', 'content': content_chunk}, ensure_ascii=False)}\n\n"
                        
                # --- å¤„ç†å·¥å…·ç»“æŸäº‹ä»¶ ---
                elif kind == "on_tool_end":
                    yield f"data: {json.dumps({'type': 'status', 'content': 'âœ… æœç´¢å®Œæˆï¼Œæ­£åœ¨æ•´ç†ç»“æœ...'}, ensure_ascii=False)}\n\n"

            # å·¥ä½œæµç»“æŸ
            yield f"data: {json.dumps({'type': 'status', 'content': 'ğŸ‰ å·¥ä½œæµæ‰§è¡Œå®Œæ¯•ï¼'}, ensure_ascii=False)}\n\n"
            
            # ä¿å­˜æœ€ç»ˆè‰ç¨¿åˆ°æ•°æ®åº“ï¼ˆåªä¿å­˜æœ€åä¸€ç‰ˆï¼‰
            if current_draft_content:
                try:
                    await save_report(topic=task, content=current_draft_content, db=db, user_id=current_user.id)
                    yield f"data: {json.dumps({'type': 'status', 'content': 'ğŸ’¾ æŠ¥å‘Šå·²ä¿å­˜åˆ°æ•°æ®åº“'}, ensure_ascii=False)}\n\n"
                except Exception as db_e:
                    print(f"æ•°æ®åº“ä¿å­˜å¤±è´¥: {db_e}")
                    yield f"data: {json.dumps({'type': 'error', 'content': f'æ•°æ®åº“ä¿å­˜å¤±è´¥: {str(db_e)}'}, ensure_ascii=False)}\n\n"

            yield "data: [DONE]\n\n"
            
        except Exception as e:
            print(f"å‘ç”Ÿé”™è¯¯: {e}")
            yield f"data: {json.dumps({'type': 'error', 'content': str(e)}, ensure_ascii=False)}\n\n"

    return StreamingResponse(event_generator(), media_type="text/event-stream")

@router.get("/history")
async def get_history_reports(
    current_user: User = Depends(get_current_user_dependency),
    db: AsyncSession = Depends(get_db)
):
    """
    è·å–å†å²æŠ¥å‘Šåˆ—è¡¨
    """
    reports = await get_history_report_list(db, current_user.id)
    return {
        "success": True,
        "message": "å†å²æŠ¥å‘Šåˆ—è¡¨è·å–æˆåŠŸ",
        "data": [
            {
                "id": report.id,
                "topic": report.topic,
                "content": report.content,
                "created_at": report.created_at.isoformat() if report.created_at else None
            }
            for report in reports
        ]
    }

@router.get("/history/{report_id}")
async def get_report_detail(
    report_id: int,
    current_user: User = Depends(get_current_user_dependency),
    db: AsyncSession = Depends(get_db)
):
    """
    è·å–å•ä¸ªæŠ¥å‘Šçš„è¯¦ç»†ä¿¡æ¯
    """
    reports = await get_history_report_list(db, current_user.id)
    for report in reports:
        if report.id == report_id:
            return {
                "success": True,
                "data": {
                    "id": report.id,
                    "topic": report.topic,
                    "content": report.content,
                    "created_at": report.created_at.isoformat() if report.created_at else None
                }
            }
    return {"success": False, "message": "æŠ¥å‘Šä¸å­˜åœ¨"}

============================================================
ğŸ“‚ File: .\routers\user.py
============================================================

from fastapi import APIRouter, Depends, HTTPException, Header
from sqlalchemy.ext.asyncio import AsyncSession

from config.db_conf import get_db
from crud.user import create_user, get_user_by_username, login_user, get_current_user
from models.users import User
from schema.user import LoginRequest, RegisterRequest
from utils.security import verify_password


router = APIRouter(prefix="/user", tags=["ç”¨æˆ·"])

async def get_token_from_header(authorization: str = Header(...)):
    """ä»è¯·æ±‚å¤´ä¸­æå– token"""
    if not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="æ— æ•ˆçš„è®¤è¯æ ¼å¼")
    return authorization[7:]

@router.post("/register")
async def register_user(request: RegisterRequest, db: AsyncSession = Depends(get_db)):
    """ç”¨æˆ·æ³¨å†Œ"""
    user = await get_user_by_username(request.username, db)
    if user:
        raise HTTPException(status_code=400, detail="ç”¨æˆ·åå·²å­˜åœ¨")
    await create_user(request, db)
    return {"msg": "ç”¨æˆ·æ³¨å†ŒæˆåŠŸ"}

@router.post("/login")
async def login(request: LoginRequest, db: AsyncSession = Depends(get_db)):
    """ç”¨æˆ·ç™»å½•"""
    user = await login_user(request, db)
    if not user:
        raise HTTPException(status_code=400, detail="ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
    return {"msg": "ç™»å½•æˆåŠŸ", "token": user["token"]}

@router.get("/me")
async def get_current_user_info(
    token: str = Depends(get_token_from_header),
    db: AsyncSession = Depends(get_db)
):
    """è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯"""
    current_user = await get_current_user(token, db)
    return {
        "id": current_user.id,
        "username": current_user.username
    }


============================================================
ğŸ“‚ File: .\schema\report.py
============================================================

from pydantic import BaseModel

class ChatRequest(BaseModel):
    query: str

============================================================
ğŸ“‚ File: .\schema\user.py
============================================================

from pydantic import BaseModel, Field


class RegisterRequest(BaseModel):
    username: str  = Field(..., min_length=8, max_length=20, description="ç”¨æˆ·å")
    password: str  = Field(..., min_length=6, max_length=20, description="å¯†ç ")

class LoginRequest(BaseModel):
    username: str  = Field(..., min_length=8, max_length=20, description="ç”¨æˆ·å")
    password: str  = Field(..., min_length=6, max_length=20, description="å¯†ç ")

============================================================
ğŸ“‚ File: .\utils\agent_tools.py
============================================================

from langchain_core.tools import tool
from zai import ZhipuAiClient
import os
import dotenv
dotenv.load_dotenv()

client = ZhipuAiClient(api_key=os.getenv("zhipu-api-key"))


@tool
def tavily_search(query: str) -> list[str]:
    """
    ä½¿ç”¨æ•°æ®è¿›è¡Œæœç´¢ã€‚
    åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œåº”åœ¨æ­¤å¤„å®ç°çœŸå®çš„æœç´¢é€»è¾‘ã€‚
    """
    try:
        response = client.web_search.web_search(
        search_engine="search_std",
        search_query=query,
        count=5,  # è¿”å›ç»“æœçš„æ¡æ•°ï¼ŒèŒƒå›´1-50ï¼Œé»˜è®¤5
        search_domain_filter=None,  # åªè®¿é—®æŒ‡å®šåŸŸåçš„å†…å®¹
        search_recency_filter="noLimit",  # æœç´¢æŒ‡å®šæ—¥æœŸèŒƒå›´å†…çš„å†…å®¹
        content_size="low"  # æ§åˆ¶ç½‘é¡µæ‘˜è¦çš„å­—æ•°ï¼Œé»˜è®¤medium
        )
        result = []
        for res in response.search_result:
            result.append(res.content)
        print(result)
        return result
    except Exception as exc:
        print(f"error: {str(exc)}")
    # print(f"æ­£åœ¨æ‰§è¡Œæ¨¡æ‹Ÿæœç´¢ï¼š{query}")
    
    # # æ¨¡æ‹Ÿè¿”å›æ•°æ®ï¼šå…³äº "2025 AI å‘å±•è¶‹åŠ¿" çš„ä¸‰æ¡å‡æ–°é—»
    # return [
    #     "1. åˆ°2025å¹´ï¼ŒAgentic AIï¼ˆä»£ç†AIï¼‰å°†æˆä¸ºä¸»æµï¼Œè‡ªä¸»Agentåœ¨æ— éœ€äººç±»å¹²é¢„çš„æƒ…å†µä¸‹å¤„ç†å¤æ‚å·¥ä½œæµã€‚",
    #     "2. ç”±äºä¸“ç”¨ç¡¬ä»¶çš„çªç ´ï¼ŒLLM æ¨ç†æˆæœ¬ä¸‹é™äº†90%ï¼Œä½¿å¾—åœ¨è¾¹ç¼˜è®¾å¤‡ä¸Šè¿›è¡Œæœ¬åœ°éƒ¨ç½²æˆä¸ºå¯èƒ½ã€‚",
    #     "3. å¤šæ¨¡æ€æ¨¡å‹å®ç°äº†è¿‘ä¹å®Œç¾çš„æ¨ç†èƒ½åŠ›ï¼Œå½»åº•æ”¹å˜äº†ç§‘å­¦ç ”ç©¶çš„è‡ªåŠ¨åŒ–è¿›ç¨‹ã€‚"
    # ]


============================================================
ğŸ“‚ File: .\utils\content_cleaner.py
============================================================

import re


def clean_code_output(code: str) -> str:
    """
    æ¸…ç†ä»£ç ç”Ÿæˆå™¨çš„è¾“å‡º
    
    Args:
        code: åŸå§‹ä»£ç è¾“å‡º
        
    Returns:
        æ¸…ç†åçš„ä»£ç 
    """
    # ç§»é™¤å¼€å¤´çš„markdownæ ‡è®°
    code = re.sub(r'^```python\s*\n', '', code, flags=re.MULTILINE)
    code = re.sub(r'^```\s*\n', '', code, flags=re.MULTILINE)
    
    # ç§»é™¤ç»“å°¾çš„markdownæ ‡è®°
    code = re.sub(r'\n```$', '', code)
    code = re.sub(r'\n```\s*$', '', code)
    
    # ç§»é™¤å¼€å¤´çš„æ‰§è¡Œè¯´æ˜
    code = re.sub(r'^è¦è¿è¡Œæ­¤ä»£ç .*?\n', '', code, flags=re.MULTILINE)
    code = re.sub(r'^è¿è¡Œæ–¹å¼.*?\n', '', code, flags=re.MULTILINE)
    code = re.sub(r'^ä½¿ç”¨æ–¹æ³•.*?\n', '', code, flags=re.MULTILINE)
    
    # ç§»é™¤å¼€å¤´çš„ç©ºè¡Œ
    code = code.lstrip('\n')
    
    return code


def clean_article_output(article: str) -> str:
    """
    æ¸…ç†æ–‡ç« ç”Ÿæˆå™¨çš„è¾“å‡º
    
    Args:
        article: åŸå§‹æ–‡ç« è¾“å‡º
        
    Returns:
        æ¸…ç†åçš„æ–‡ç« 
    """
    # ç§»é™¤å¼€å¤´çš„æ‰§è¡Œè¯´æ˜
    article = re.sub(r'^è¦è¿è¡Œæ­¤ä»£ç .*?\n', '', article, flags=re.MULTILINE)
    article = re.sub(r'^è¿è¡Œæ–¹å¼.*?\n', '', article, flags=re.MULTILINE)
    article = re.sub(r'^ä½¿ç”¨æ–¹æ³•.*?\n', '', article, flags=re.MULTILINE)
    article = re.sub(r'^ä¿å­˜ä¸º.*?\n', '', article, flags=re.MULTILINE)
    
    # ç¡®ä¿ä»£ç å—æ­£ç¡®é—­åˆ
    # æŸ¥æ‰¾æœªé—­åˆçš„ä»£ç å—
    code_blocks = re.findall(r'```python\n(.*?)\n```', article, re.DOTALL)
    open_blocks = len(re.findall(r'```python', article))
    close_blocks = len(re.findall(r'```', article)) - open_blocks
    
    # å¦‚æœæœ‰æœªé—­åˆçš„ä»£ç å—ï¼Œå°è¯•ä¿®å¤
    if open_blocks > close_blocks:
        article += '\n```'
    
    # ç§»é™¤å¼€å¤´çš„ç©ºè¡Œ
    article = article.lstrip('\n')
    
    return article


def clean_search_query(query: str) -> str:
    """
    æ¸…ç†æœç´¢æŸ¥è¯¢ï¼Œæå–æ ¸å¿ƒå…³é”®è¯
    
    Args:
        query: åŸå§‹ä»»åŠ¡æè¿°
        
    Returns:
        æ¸…ç†åçš„æœç´¢æŸ¥è¯¢
    """
    # ç§»é™¤å¸¸è§çš„å‰ç¼€
    prefixes = ['å†™ä¸€ç¯‡', 'æ’°å†™', 'å…³äº', 'åˆ†æ', 'å®ç°', 'å¼€å‘', 'ç”Ÿæˆ', 'å¸®æˆ‘', 'è¯·', 'ç”¨']
    for prefix in prefixes:
        if query.startswith(prefix):
            query = query[len(prefix):]
            break
    
    # ç§»é™¤å¸¸è§çš„åç¼€
    suffixes = ['çš„æ–‡ç« ', 'çš„æŠ¥å‘Š', 'çš„å†…å®¹', 'çš„ä»£ç ', 'çš„ç®—æ³•', 'çš„ç¨‹åº']
    for suffix in suffixes:
        if query.endswith(suffix):
            query = query[:-len(suffix)]
            break
    
    # æ¸…ç†æ ‡ç‚¹ç¬¦å·
    query = query.strip()
    query = query.rstrip('ï¼Ÿ?ã€‚.ï¼!')
    
    return query


def fix_fstring_issues(code: str) -> str:
    """
    ä¿®å¤ f-string ä¸­çš„è¯­æ³•é—®é¢˜
    
    Args:
        code: åŸå§‹ä»£ç 
        
    Returns:
        ä¿®å¤åçš„ä»£ç 
    """
    # æŸ¥æ‰¾æ‰€æœ‰ f-string
    pattern = r'f"([^"]*?\{[^}]*\}[^"]*?)"'
    
    def fix_fstring(match):
        content = match.group(1)
        # æ£€æŸ¥æ˜¯å¦åŒ…å«å¤æ‚è¡¨è¾¾å¼
        if re.search(r'\{[^}]*[.()[\]]', content):
            # æå–å˜é‡å
            variables = re.findall(r'\{([^}]+)\}', content)
            # ç”Ÿæˆä¿®å¤åçš„ä»£ç 
            result = []
            for var in variables:
                # å¦‚æœæ˜¯ç®€å•å˜é‡ï¼Œä¿ç•™
                if not re.search(r'[.()[\]]', var):
                    result.append(f'{{{var}}}')
                else:
                    # å¤æ‚è¡¨è¾¾å¼ï¼Œéœ€è¦å…ˆèµ‹å€¼
                    var_name = re.sub(r'[^a-zA-Z0-9_]', '_', var)
                    result.append(f'{{{var_name}}}')
            return f'f"{" ".join(result)}"'
        return match.group(0)
    
    return re.sub(pattern, fix_fstring, code)


============================================================
ğŸ“‚ File: .\utils\my_llm.py
============================================================

import os 
import dotenv
from langchain_openai import ChatOpenAI

dotenv.load_dotenv()


llm = ChatOpenAI(model=os.getenv("deepseek-model-name"),
                 api_key=os.getenv("deepseek-api-key"),
                 base_url=os.getenv("deepseek-api-base"),
                 temperature=0.5)



============================================================
ğŸ“‚ File: .\utils\security.py
============================================================

from passlib.context import CryptContext


bcrypt_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return bcrypt_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return bcrypt_context.verify(plain_password, hashed_password)
